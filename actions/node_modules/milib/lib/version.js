"use strict";
// /**
//  * Check if version string contains only dots, hyphens and numbers:
//  *  - 1.2.3    -> true
//  *  - 1.0.4-1  -> true
//  *  - 3.9.4a   -> false (a is letter)
//  */
// export function isNumeric(v: string): boolean {
//   const n = Number(v.replaceAll(/[-.]/g, ""));
//   return !Number.isNaN(n);
// }
Object.defineProperty(exports, "__esModule", { value: true });
exports.toString = exports.compare = exports.parse = void 0;
function isNumber(v) {
    const n = Number(v);
    return !Number.isNaN(n);
}
function parse(v) {
    const parts = v.split(".");
    const result = {
        major: 0,
        minor: 0,
        patch: 0,
        suffix: "",
        original: v,
        semver: false, // the version seems to conform with semver
    };
    if (isNumber(parts[0])) {
        result.major = Number(parts[0]);
    }
    else {
        result.suffix = v;
    }
    if (parts.length === 1) {
        // Only <major> version part or completely unknown version format
        result.semver = isNumber(parts[0]);
        return result;
    }
    // parts.length >= 2
    if (!isNumber(parts[1])) {
        // Unknown version format. E.g. '3.alpha'
        result.suffix = parts.slice(1).join(".");
        return result;
    }
    result.minor = Number(parts[1]);
    if (parts.length === 2) {
        // Incomplete semver format: <major>.<minor>
        result.semver = true;
        return result;
    }
    // parts.length >=3
    if (isNumber(parts[2])) {
        // Regular semver with numeric <patch> part: <major>.<minor>.<patch>
        result.patch = Number(parts[2]);
        result.semver = parts.length === 3;
        if (parts.length > 3) {
            // Custom case with additional version parts: <major>.<minor>.<patch>.<...>
            // Put rest of dots into 'suffix' field: <major>.<minor>.<patch>.<suffix>
            result.suffix = parts.slice(3).join(".");
        }
        return result;
    }
    // parts.length >= 3 and parts[2] is not a number:
    // Cases:
    //   - 2.2.abra
    //   - 2.2.abra.kadabra
    //   - 2.2.abra-kadabra
    //   - 0.2.3-custom
    //   - 1.2.3-alpha.2
    const patch_parts = parts[2].split("-");
    if (patch_parts.length === 1) {
        // <patch> version parts has no '-' delimiters and not a number.
        // Treat non-numeric <patch> version as suffix: <major>.<minor>.<suffix>
        // Cases:
        //   - 2.2.abrakadabra
        //   - 2.2.abra.kadabra
        result.suffix = parts.slice(2).join(".");
        return result;
    }
    // <patch> version consists of several '-'-delimited fields
    if (!isNumber(patch_parts[0])) {
        // Treat non-numeric <patch> version as suffix: <major>.<minor>.<suffix>
        // Cases:
        //    - 2.2.abra-kadabra
        result.suffix = parts.slice(2).join(".");
        return result;
    }
    // Canonical semver case with suffix: <major>.<minor>.<patch>-<suffix>
    // Cases:
    //   - 0.2.3-custom
    //   - 1.2.3-alpha.2
    result.patch = Number(patch_parts[0]);
    let suffix = patch_parts.slice(1).join("-");
    if (parts.length > 3) {
        suffix = `${suffix}.${parts.slice(3).join(".")}`;
    }
    result.suffix = suffix;
    result.semver = true;
    return result;
}
exports.parse = parse;
function compare(a, b) {
    if (a.major < b.major) {
        return -1;
    }
    if (a.major > b.major) {
        return 1;
    }
    if (a.minor < b.minor) {
        return -1;
    }
    if (a.minor > b.minor) {
        return 1;
    }
    if (a.patch < b.patch) {
        return -1;
    }
    if (a.patch > b.patch) {
        return 1;
    }
    // Last resort: compare as plain strings.
    if (a.original < b.original) {
        return -1;
    }
    if (a.original > b.original) {
        return 1;
    }
    return 0;
}
exports.compare = compare;
function toString(v) {
    if (!v.semver) {
        return v.original;
    }
    if (v.suffix === "") {
        return `${v.major}.${v.minor}.${v.patch}`;
    }
    return `${v.major}.${v.minor}.${v.patch}-${v.suffix}`;
}
exports.toString = toString;
