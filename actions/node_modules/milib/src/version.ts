// /**
//  * Check if version string contains only dots, hyphens and numbers:
//  *  - 1.2.3    -> true
//  *  - 1.0.4-1  -> true
//  *  - 3.9.4a   -> false (a is letter)
//  */
// export function isNumeric(v: string): boolean {
//   const n = Number(v.replaceAll(/[-.]/g, ""));
//   return !Number.isNaN(n);
// }

function isNumber(v: string): boolean {
  const n = Number(v);
  return !Number.isNaN(n);
}

// <major>.<minor>.<patch>[-<suffix> | .<suffix>]
export interface versionInfo {
  major: number;
  minor: number;
  patch: number;
  suffix: string;
  original: string;
  parsed: boolean;
}

export function parse(v: string): versionInfo {
  const parts = v.split(".");

  const result = {
    major: 0,
    minor: 0,
    patch: 0,
    suffix: "", // part of the version string left after main fields parsing
    original: v, // original version string parsed by parser
    parsed: false, // the parser succeed to fully parse version number format
  } as versionInfo;

  if (isNumber(parts[0])) {
    result.major = Number(parts[0]);
  } else {
    result.suffix = v;
  }

  if (parts.length === 1) {
    // Only <major> version part or completely unknown version format
    result.parsed = isNumber(parts[0]);
    return result;
  }

  // parts.length >= 2
  if (isNumber(parts[1])) {
    result.minor = Number(parts[1]);
  } else {
    // Unknown version format. E.g. '3.alpha'
    result.suffix = parts.slice(1).join(".");
    return result;
  }

  if (parts.length === 2) {
    // Incomplete semver format: <major>.<minor>
    result.parsed = true;
    return result;
  }

  // parts.length >=3
  if (isNumber(parts[2])) {
    // Regular semver with numeric <patch> part: <major>.<minor>.<patch>
    result.patch = Number(parts[2]);
    result.parsed = true;

    if (parts.length > 3) {
      // Custom case with additional version parts: <major>.<minor>.<patch>.<...>
      // Put rest of dots into 'suffix' field: <major>.<minor>.<patch>.<suffix>
      result.suffix = parts.slice(3).join(".");
    }
    return result;
  }

  // parts.length >= 3 and parts[2] is not a number:
  // Cases:
  //   - 2.2.abra
  //   - 2.2.abra.kadabra
  //   - 2.2.abra-kadabra
  //   - 0.2.3-custom
  //   - 1.2.3-alpha.2

  const patch_parts = parts[2].split("-");
  if (patch_parts.length === 1) {
    // <patch> version parts has no '-' delimiters and not a number.
    // Treat non-numeric <patch> version as suffix: <major>.<minor>.<suffix>
    // Cases:
    //   - 2.2.abrakadabra
    //   - 2.2.abra.kadabra
    result.suffix = parts.slice(2).join(".");
    result.parsed = true;
    return result;
  }

  // <patch> version consists of several '-'-delimited fields
  if (!isNumber(patch_parts[0])) {
    // Treat non-numeric <patch> version as suffix: <major>.<minor>.<suffix>
    // Cases:
    //    - 2.2.abra-kadabra
    result.suffix = parts.slice(2).join(".");
    result.parsed = true;
    return result;
  }

  // Canonical semver case with suffix: <major>.<minor>.<patch>-<suffix>
  // Cases:
  //   - 0.2.3-custom
  //   - 1.2.3-alpha.2
  result.patch = Number(patch_parts[0]);
  let suffix = patch_parts.slice(1).join("-");
  if (parts.length > 3) {
    suffix = `${suffix}.${parts.slice(3).join(".")}`;
  }
  result.suffix = suffix;
  result.parsed = true;
  return result;
}

export function compare(a: versionInfo, b: versionInfo): number {
  if (a.major < b.major) {
    return -1;
  }
  if (a.major > b.major) {
    return 1;
  }

  if (a.minor < b.minor) {
    return -1;
  }
  if (a.minor > b.minor) {
    return 1;
  }

  if (a.patch < b.patch) {
    return -1;
  }
  if (a.patch > b.patch) {
    return 1;
  }

  // Last resort: compare as plain strings.
  if (a.original < b.original) {
    return -1;
  }
  if (a.original > b.original) {
    return 1;
  }

  return 0;
}
